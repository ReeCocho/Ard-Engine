use ard_math::{Vec2, Vec4};
use serde::{Deserialize, Serialize};

use crate::ObjectBounds;

#[derive(Debug, Serialize, Deserialize, Default, Copy, Clone, PartialEq, Eq, Hash)]
pub struct VertexLayout {
    pub normals: bool,
    pub tangents: bool,
    pub colors: bool,
    pub uv0: bool,
    pub uv1: bool,
    pub uv2: bool,
    pub uv3: bool,
}

#[derive(Default)]
pub struct MeshCreateInfo<'a> {
    pub bounds: MeshBounds,
    pub indices: &'a [u32],
    pub positions: &'a [Vec4],
    /// If `Some`, must be the same length as `positions`.
    pub normals: Option<&'a [Vec4]>,
    /// If `Some`, must be the same length as `positions`.
    pub tangents: Option<&'a [Vec4]>,
    /// If `Some`, must be the same length as `positions`.
    pub colors: Option<&'a [Vec4]>,
    /// If `Some`, must be the same length as `positions`.
    pub uv0: Option<&'a [Vec2]>,
    /// If `Some`, must be the same length as `positions`.
    pub uv1: Option<&'a [Vec2]>,
    /// If `Some`, must be the same length as `positions`.
    pub uv2: Option<&'a [Vec2]>,
    /// If `Some`, must be the same length as `positions`.
    pub uv3: Option<&'a [Vec2]>,
}

/// Object bounds for a mesh.
#[derive(Debug, Copy, Clone)]
pub enum MeshBounds {
    /// Manually set the bounds.
    Manual(ObjectBounds),
    /// Bounds are autogenerated from the positions list.
    Generate,
}

/// A mesh describes the physical geometry of an object.
pub trait MeshApi: Clone + Send + Sync {
    fn index_count(&self) -> usize;

    fn vertex_count(&self) -> usize;

    fn bounds(&self) -> ObjectBounds;
}

impl<'a> MeshCreateInfo<'a> {
    /// Get the bounds for the positions contained.
    pub fn bounds(&self) -> ObjectBounds {
        if let MeshBounds::Manual(bounds) = self.bounds {
            return bounds;
        }

        if self.positions.is_empty() {
            return ObjectBounds::default();
        }

        let mut min = self.positions[0];
        let mut max = self.positions[0];
        let mut sqr_radius = min.x.powi(2) + min.z.powi(2) + min.y.powi(2);

        for position in self.positions {
            let new_sqr_radius = position.x.powi(2) + position.z.powi(2) + position.y.powi(2);

            if new_sqr_radius > sqr_radius {
                sqr_radius = new_sqr_radius;
            }

            if position.x < min.x {
                min.x = position.x;
            }

            if position.y < min.y {
                min.y = position.y;
            }

            if position.z < min.z {
                min.z = position.z;
            }

            if position.x > max.x {
                max.x = position.x;
            }

            if position.y > max.y {
                max.y = position.y;
            }

            if position.z > max.z {
                max.z = position.z;
            }
        }

        ObjectBounds {
            center: Vec4::new(
                (max.x + min.x) / 2.0,
                (max.y + min.y) / 2.0,
                (max.z + min.z) / 2.0,
                sqr_radius.sqrt(),
            ),
            half_extents: Vec4::new(
                (max.x - min.x) / 2.0,
                (max.y - min.y) / 2.0,
                (max.z - min.z) / 2.0,
                1.0,
            ),
        }
    }

    #[inline]
    pub fn vertex_layout(&self) -> VertexLayout {
        VertexLayout {
            normals: self.normals.is_some(),
            tangents: self.tangents.is_some(),
            colors: self.colors.is_some(),
            uv0: self.uv0.is_some(),
            uv1: self.uv1.is_some(),
            uv2: self.uv2.is_some(),
            uv3: self.uv3.is_some(),
        }
    }
}

impl Default for MeshBounds {
    fn default() -> Self {
        MeshBounds::Manual(ObjectBounds::default())
    }
}

impl VertexLayout {
    /// Returns `true` if this vertex layout contains a subset of the vertex components of `other`.
    #[inline]
    pub fn subset_of(&self, other: &VertexLayout) -> bool {
        (!self.normals || other.normals)
            && (!self.tangents || other.tangents)
            && (!self.colors || other.colors)
            && (!self.uv0 || other.uv0)
            && (!self.uv1 || other.uv1)
            && (!self.uv2 || other.uv2)
            && (!self.uv3 || other.uv3)
    }
}
