#version 450 core
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_scalar_block_layout : enable

// Most of the code for this comes from here:
// https://miketuritzin.com/post/hierarchical-depth-buffers/

#define ARD_SET_DRAW_GEN 0
#define ARD_SET_CAMERA 1
#include "ard_types.glsl"
#include "ard_bindings.glsl"

layout(local_size_x_id = 0) in;
layout(local_size_y_id = 1) in;
layout(local_size_z_id = 2) in;

layout(push_constant) uniform constants {
    DrawGenPushConstants consts;
};

struct BoundingBox {
    /// All eight corners of the box in world space.
    vec4[8] corners;
    /// Min point for AABB in screen space.
    vec2 min_pt;
    /// Max point for AABB in screen space.
    vec2 max_pt;
    /// Depth value for the AABB square in world space.
    float depth;
};

/// Transforms the bounding box via the given model matrix.
BoundingBox transform_bounding_box(mat4 model, vec4 center, vec4 half_extents) {
    BoundingBox bb;

    half_extents.x = max(half_extents.x + 0.1, 0.1);
    half_extents.y = max(half_extents.y + 0.1, 0.1);
    half_extents.z = max(half_extents.z + 0.1, 0.1);

    // Compute all eight corners
    mat4 vm = camera.view * model;
    bb.corners[0] = vm * vec4(center.xyz + vec3(+half_extents.x, +half_extents.y, +half_extents.z), 1.0);
    bb.corners[1] = vm * vec4(center.xyz + vec3(-half_extents.x, +half_extents.y, +half_extents.z), 1.0);
    bb.corners[2] = vm * vec4(center.xyz + vec3(-half_extents.x, -half_extents.y, +half_extents.z), 1.0);
    bb.corners[3] = vm * vec4(center.xyz + vec3(-half_extents.x, +half_extents.y, -half_extents.z), 1.0);
    bb.corners[4] = vm * vec4(center.xyz + vec3(+half_extents.x, -half_extents.y, -half_extents.z), 1.0);
    bb.corners[5] = vm * vec4(center.xyz + vec3(+half_extents.x, -half_extents.y, +half_extents.z), 1.0);
    bb.corners[6] = vm * vec4(center.xyz + vec3(+half_extents.x, +half_extents.y, -half_extents.z), 1.0);
    bb.corners[7] = vm * vec4(center.xyz + vec3(-half_extents.x, -half_extents.y, -half_extents.z), 1.0);

    // Then find the min and max points in screen space
    bb.min_pt = vec2(uintBitsToFloat(0x7F800000));
    bb.max_pt = vec2(uintBitsToFloat(0xFF800000));
    bb.depth = uintBitsToFloat(0x7F800000);

    [[unroll]]
    for (int i = 0; i < 8; i++) {
        // Depth
        bb.depth = min(bb.depth, bb.corners[i].z);
    
        bb.corners[i] = camera.projection * bb.corners[i];
        bb.corners[i] /= bb.corners[i].w;
        vec4 pt = bb.corners[i];

        // Min
        bb.min_pt.x = min(bb.min_pt.x, pt.x);
        bb.min_pt.y = min(bb.min_pt.y, pt.y);

        // Max
        bb.max_pt.x = max(bb.max_pt.x, pt.x);
        bb.max_pt.y = max(bb.max_pt.y, pt.y);
    }

    return bb;
}

void main() {
    // Stop early if we've hit the object limit
    uint object_index = gl_GlobalInvocationID.x;
    if (object_index >= consts.object_count) {
        return;
    }

    // Grab the object
    ObjectId obj = input_ids[object_index];
    uint draw_idx = obj.draw_idx[0];
    mat4 model = objects[obj.data_idx].model;

    // Frustum culling using sphere radius
    vec4 bounds_center = draw_calls[draw_idx].bounds.center;
    vec4 pos = model * vec4(bounds_center.xyz, 1.0);
    vec3 scale = vec3(
        dot(model[0].xyz, model[0].xyz),
        dot(model[1].xyz, model[1].xyz),
        dot(model[2].xyz, model[2].xyz)
    );
    float radius = bounds_center.w * sqrt(max(scale.x, max(scale.y, scale.z)));

    [[unroll]]
    for (int i = 0; i < 6; i++) { 
        if (dot(vec4(pos.xyz, 1.0), camera.frustum.planes[i]) < -radius) {
            // return;
        }
    }

    // TODO: HZB occlusion culling

    // Insert the object into the output list and notify the associated call of the object
    uint model_offset = atomicAdd(draw_calls[draw_idx].instance_count, 1);
    uint instance_index = draw_calls[draw_idx].first_instance + model_offset;
    output_ids[instance_index] = obj.data_idx;
}