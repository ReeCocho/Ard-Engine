#version 450 core
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_scalar_block_layout : enable

#define ARD_SET_DRAW_COMPACT 0
#include "ard_types.glsl"
#include "ard_bindings.glsl"

layout(local_size_x_id = 0) in;
layout(local_size_y_id = 1) in;
layout(local_size_z_id = 2) in;

layout(push_constant) uniform constants {
    DrawCompactPushConstants consts;
};

void main() {
    // Stop early if we've hit the object limit
    if (gl_GlobalInvocationID.x >= consts.draw_call_count) {
        return;
    }

    // Grab the draw call
    const uint draw_index = gl_GlobalInvocationID.x + consts.base_draw_call;
    const DrawGroup group = draw_groups_src[draw_index];
    const MeshInfo mi = mesh_info[group.mesh];

    // Reset if requested
    if (consts.reset_group_counts > 0) {
        draw_groups_src[draw_index].instance_count = 0;
    }

    DrawCall call;
    call.first_instance = group.first_instance;
    call.instance_count = group.instance_count;
    call.index_count = mi.index_count;
    call.first_index = mi.first_index;
    call.vertex_offset = mi.vertex_offset;

    // If this call is transparent, we want to preserve ordering, so we just insert into the
    // bin like so (even if the instance count is 0)
    if (gl_GlobalInvocationID.x >= consts.transparent_start) {
        const uint bin_base = draw_counts[(group.draw_bin * 2) + 1];
        atomicAdd(draw_counts[group.draw_bin * 2], 1);
        draw_calls_dst[bin_base + group.bin_offset] = call;
        return;
    }

    // If the draw count is equal to 0, we can cull this draw
    if (call.instance_count == 0) {
        return;
    }

    // Otherwise, we lookup the bin base for this draw and increment the bin's draw count
    const uint bin_offset = atomicAdd(draw_counts[group.draw_bin * 2], 1);
    const uint bin_base = draw_counts[(group.draw_bin * 2) + 1];
    draw_calls_dst[bin_base + bin_offset] = call;
}