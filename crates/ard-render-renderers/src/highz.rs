use ard_math::*;
use ard_pal::prelude::*;
use ard_render_base::ecs::Frame;
use ard_render_si::{bindings::*, types::GpuHzbGenPushConstants};
use ordered_float::NotNan;

/// Renderer used to generate hierarchical depth buffers.
pub struct HzbRenderer {
    ctx: Context,
    layout: DescriptorSetLayout,
    pipeline: ComputePipeline,
}

/// Hierarchical depth buffer used for occlusion culling. Generated by `HzbRenderer`.
pub struct HzbImage<const FIF: usize> {
    image: Texture,
    sets: [Vec<DescriptorSet>; FIF],
    src_dims: (u32, u32, u32),
}

const HZB_INPUT_SAMPLER: Sampler = Sampler {
    min_filter: Filter::Nearest,
    mag_filter: Filter::Nearest,
    mipmap_filter: Filter::Nearest,
    address_u: SamplerAddressMode::ClampToEdge,
    address_v: SamplerAddressMode::ClampToEdge,
    address_w: SamplerAddressMode::ClampToEdge,
    anisotropy: None,
    compare: None,
    min_lod: unsafe { NotNan::new_unchecked(0.0) },
    max_lod: None,
    unnormalize_coords: false,
    border_color: None,
};

impl HzbRenderer {
    pub fn new(ctx: &Context, layouts: &Layouts) -> Self {
        let module = Shader::new(
            ctx.clone(),
            ShaderCreateInfo {
                code: include_bytes!(concat!(env!("OUT_DIR"), "./hzb_gen.comp.spv")),
                debug_name: Some("hzb_gen_shader".into()),
            },
        )
        .unwrap();

        let pipeline = ComputePipeline::new(
            ctx.clone(),
            ComputePipelineCreateInfo {
                layouts: vec![layouts.hzb_gen.clone()],
                module,
                work_group_size: (2, 2, 1),
                push_constants_size: Some(std::mem::size_of::<GpuHzbGenPushConstants>() as u32),
                debug_name: Some("hzb_gen_pipeline".into()),
            },
        )
        .unwrap();

        Self {
            ctx: ctx.clone(),
            pipeline,
            layout: layouts.hzb_gen.clone(),
        }
    }

    pub fn generate<'a, const FIF: usize>(
        &self,
        frame: Frame,
        commands: &mut CommandBuffer<'a>,
        image: &'a HzbImage<FIF>,
    ) {
        commands.compute_pass(|pass| {
            // Bind the pipeline for hzb gen
            pass.bind_pipeline(self.pipeline.clone());

            // Perform a dispatch for each mip level
            for (i, set) in image.sets[usize::from(frame)].iter().enumerate() {
                // Determine the size of this mip level
                let (mut src_width, mut src_height, _) = image.src_dims;
                let dst_width = (src_width >> (i + 1)).max(1);
                let dst_height = (src_height >> (i + 1)).max(1);
                src_width = (src_width >> i).max(1);
                src_height = (src_height >> i).max(1);

                // Determine the conversion factor for texels
                let constants = [GpuHzbGenPushConstants {
                    input_size: IVec2::new(src_width as i32, src_height as i32),
                    inv_output_size: 1.0 / Vec2::new(dst_width as f32, dst_height as f32),
                }];

                // Send constants and dispatch
                pass.bind_sets(0, vec![set]);
                pass.push_constants(bytemuck::cast_slice(&constants));
                pass.dispatch(dst_width, dst_height, 1);
            }
        });
    }
}

impl<const FIF: usize> HzbImage<FIF> {
    pub fn new(renderer: &HzbRenderer, width: u32, height: u32) -> Self {
        let mip_levels = (width.max(height) as f32).log2().floor() as usize;
        let image = Texture::new(
            renderer.ctx.clone(),
            TextureCreateInfo {
                format: Format::R32SFloat,
                ty: TextureType::Type2D,
                width: (width / 2).max(1),
                height: (height / 2).max(1),
                depth: 1,
                array_elements: 1,
                mip_levels,
                texture_usage: TextureUsage::SAMPLED | TextureUsage::STORAGE,
                memory_usage: MemoryUsage::GpuOnly,
                debug_name: Some(String::from("hzb_image")),
            },
        )
        .unwrap();

        let sets = std::array::from_fn(|_| {
            let mut mip_sets = Vec::with_capacity(mip_levels);

            for i in 0..mip_levels {
                let mut mip_set = DescriptorSet::new(
                    renderer.ctx.clone(),
                    DescriptorSetCreateInfo {
                        layout: renderer.layout.clone(),
                        debug_name: Some(format!("hzb_mip_set_{i}")),
                    },
                )
                .unwrap();

                // Write in the images
                if i == 0 {
                    mip_set.update(&[DescriptorSetUpdate {
                        binding: HZB_GEN_SET_OUTPUT_DEPTH_BINDING,
                        array_element: 0,
                        value: DescriptorValue::StorageImage {
                            texture: &image,
                            array_element: 0,
                            mip: 0,
                        },
                    }]);
                } else {
                    mip_set.update(&[
                        DescriptorSetUpdate {
                            binding: HZB_GEN_SET_INPUT_DEPTH_BINDING,
                            array_element: 0,
                            value: DescriptorValue::Texture {
                                texture: &image,
                                array_element: 0,
                                sampler: HZB_INPUT_SAMPLER,
                                base_mip: i - 1,
                                mip_count: 1,
                            },
                        },
                        DescriptorSetUpdate {
                            binding: HZB_GEN_SET_OUTPUT_DEPTH_BINDING,
                            array_element: 0,
                            value: DescriptorValue::StorageImage {
                                texture: &image,
                                array_element: 0,
                                mip: i,
                            },
                        },
                    ]);
                }

                mip_sets.push(mip_set);
            }

            mip_sets
        });

        HzbImage {
            image,
            sets,
            src_dims: (width, height, 1),
        }
    }

    pub fn bind_src(&mut self, frame: Frame, src: &Texture) {
        assert_eq!(
            self.src_dims,
            src.dims(),
            "source image must be the same size as the HZB"
        );

        // Bind the source image to the HZB image
        self.sets[usize::from(frame)][0].update(&[DescriptorSetUpdate {
            binding: HZB_GEN_SET_INPUT_DEPTH_BINDING,
            array_element: 0,
            value: DescriptorValue::Texture {
                texture: src,
                array_element: 0,
                sampler: HZB_INPUT_SAMPLER,
                base_mip: 0,
                mip_count: 1,
            },
        }]);
    }

    #[inline(always)]
    pub fn tex(&self) -> &Texture {
        &self.image
    }
}
