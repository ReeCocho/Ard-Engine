use std::ops::{DerefMut, Range};

use ard_formats::mesh::VertexLayout;
use ard_log::*;
use ard_math::*;
use ard_pal::prelude::*;
use ard_render_base::{
    ecs::Frame,
    resource::{ResourceAllocator, ResourceId},
};
use ard_render_camera::ubo::CameraUbo;
use ard_render_material::{
    factory::{MaterialFactory, PassId},
    material::{MaterialResource, MaterialVariantRequest},
};
use ard_render_meshes::{factory::MeshFactory, mesh::MeshResource};
use ard_render_objects::set::DrawGroup;
use ard_render_si::types::{GpuDrawCall, GpuObjectBounds};
use ard_render_textures::factory::TextureFactory;

use crate::{
    global::GlobalSets,
    state::{BindingDelta, RenderStateTracker},
};

pub const DEFAULT_DRAW_CALL_CAP: usize = 1;
pub const DEFAULT_DRAW_COUNT_CAP: usize = 1;

pub struct DrawBins {
    bins: Vec<DrawBinSet>,
    use_alternate_draw_buffer: Vec<bool>,
    buffers: DrawBinBuffers,
}

#[derive(Default)]
struct DrawBinSet {
    bins: Vec<DrawBin>,
    highz_rng: Range<usize>,
    non_transparent_rng: Range<usize>,
    transparent_rng: Range<usize>,
}

pub enum DrawBinBuffers {
    CpuDriven {
        /// This is the draw call buffer written to by the CPU.
        ///
        /// See `GpuDriven::dst_draw_calls` for array element count.
        draw_calls: Buffer,
        /// This is the draw call buffer written to by the CPU.
        ///
        /// See `GpuDriven::dst_draw_calls` for array element count.
        counts: Buffer,
    },
    GpuDriven {
        /// This is the draw call buffer written to by the CPU. There is an array element per frame in
        /// flight.
        src_draw_calls: Buffer,
        /// This is the draw call buffer generated by the draw generation compute shader.
        ///
        /// There is are two array elements per frame in flight, allowing you to ping-pong between the
        /// buffers, using the old frames buffer for occlusion culling.
        dst_draw_calls: Buffer,
        /// This is the draw count buffer.
        ///
        /// See `GpuDriven::dst_draw_calls` for array element count.
        counts: Buffer,
    },
}

#[derive(Debug, Copy, Clone)]
pub struct BinGenOutput {
    /// The number of draw calls proccessed.
    pub draw_count: usize,
    /// The number of objects processed.
    pub object_count: usize,
    /// The number of bins generated.
    pub bin_count: usize,
}

pub struct RenderArgs<'a, 'b, const FIF: usize> {
    pub pass_id: PassId,
    pub frame: Frame,
    pub pass: &'b mut RenderPass<'a>,
    pub camera: &'a CameraUbo,
    pub global: &'a GlobalSets,
    pub mesh_factory: &'a MeshFactory,
    pub material_factory: &'a MaterialFactory<FIF>,
    pub texture_factory: &'a TextureFactory,
    pub meshes: &'a ResourceAllocator<MeshResource, FIF>,
    pub materials: &'a ResourceAllocator<MaterialResource, FIF>,
}

/// A draw bin represents a set of draw groups that have the same vertex layout and material,
/// meaning they can all be rendered with a single draw indirect command.
#[derive(Debug, Copy, Clone)]
pub struct DrawBin {
    /// Indicates that this draw bin should be skipped when rendering. This is usually because some
    /// resource (like the mesh) is not ready for rendering.
    pub skip: bool,
    /// The number of draw calls contained within the bin.
    pub count: usize,
    /// Offset (measured in draw calls) for the beginning of this bin.
    pub offset: usize,
    /// Contains the resource ID for the material instance to use, or `None` if the previous bin's
    /// material was identical.
    pub material: Option<ResourceId>,
    /// Contains the vertex layout to use, or `None` if the previous bin's layout was identical.
    pub vertices: Option<VertexLayout>,
    /// Contains the material data size needed for this bin, or `None` if the previous bin's
    /// data size was identical.
    pub data_size: Option<u32>,
}

impl DrawBins {
    pub fn new(ctx: &Context, frames_in_flight: usize, gpu_driven: bool) -> Self {
        let dst_draw_calls = Buffer::new(
            ctx.clone(),
            BufferCreateInfo {
                size: (DEFAULT_DRAW_CALL_CAP * std::mem::size_of::<GpuDrawCall>()) as u64,
                array_elements: frames_in_flight * 2,
                buffer_usage: BufferUsage::STORAGE_BUFFER | BufferUsage::INDIRECT_BUFFER,
                memory_usage: if gpu_driven {
                    MemoryUsage::GpuOnly
                } else {
                    MemoryUsage::CpuToGpu
                },
                queue_types: QueueTypes::MAIN | QueueTypes::COMPUTE,
                sharing_mode: SharingMode::Exclusive,
                debug_name: Some("dst_draw_calls".to_owned()),
            },
        )
        .unwrap();

        let counts = Buffer::new(
            ctx.clone(),
            BufferCreateInfo {
                size: (DEFAULT_DRAW_COUNT_CAP * std::mem::size_of::<u32>() * 2) as u64,
                array_elements: frames_in_flight * 2,
                buffer_usage: BufferUsage::STORAGE_BUFFER | BufferUsage::INDIRECT_BUFFER,
                memory_usage: MemoryUsage::CpuToGpu,
                queue_types: QueueTypes::MAIN | QueueTypes::COMPUTE,
                sharing_mode: SharingMode::Exclusive,
                debug_name: Some("draw_counts".to_owned()),
            },
        )
        .unwrap();

        Self {
            bins: (0..(frames_in_flight * 2))
                .map(|_| DrawBinSet::default())
                .collect(),
            buffers: if gpu_driven {
                DrawBinBuffers::GpuDriven {
                    src_draw_calls: Buffer::new(
                        ctx.clone(),
                        BufferCreateInfo {
                            size: (DEFAULT_DRAW_CALL_CAP * std::mem::size_of::<GpuDrawCall>())
                                as u64,
                            array_elements: frames_in_flight,
                            buffer_usage: BufferUsage::STORAGE_BUFFER
                                | BufferUsage::INDIRECT_BUFFER,
                            memory_usage: MemoryUsage::CpuToGpu,
                            queue_types: QueueTypes::MAIN | QueueTypes::COMPUTE,
                            sharing_mode: SharingMode::Exclusive,
                            debug_name: Some("src_draw_calls".to_owned()),
                        },
                    )
                    .unwrap(),
                    dst_draw_calls,
                    counts,
                }
            } else {
                DrawBinBuffers::CpuDriven {
                    draw_calls: dst_draw_calls,
                    counts,
                }
            },
            use_alternate_draw_buffer: vec![false; frames_in_flight],
        }
    }

    #[inline(always)]
    pub fn src_draw_call_buffer(&self, frame: Frame) -> Option<(&Buffer, usize)> {
        match &self.buffers {
            DrawBinBuffers::CpuDriven { .. } => None,
            DrawBinBuffers::GpuDriven { src_draw_calls, .. } => {
                Some((src_draw_calls, usize::from(frame)))
            }
        }
    }

    #[inline(always)]
    pub fn dst_draw_call_buffer(&self, frame: Frame) -> (&Buffer, usize) {
        match &self.buffers {
            DrawBinBuffers::CpuDriven { draw_calls, .. } => {
                (draw_calls, self.draw_call_buffer_idx(frame))
            }
            DrawBinBuffers::GpuDriven { dst_draw_calls, .. } => {
                (dst_draw_calls, self.draw_call_buffer_idx(frame))
            }
        }
    }

    #[inline(always)]
    pub fn draw_counts_buffer(&self, frame: Frame) -> (&Buffer, usize) {
        match &self.buffers {
            DrawBinBuffers::CpuDriven { counts, .. } => (counts, self.draw_call_buffer_idx(frame)),
            DrawBinBuffers::GpuDriven { counts, .. } => (counts, self.draw_call_buffer_idx(frame)),
        }
    }

    #[inline(always)]
    fn last_draw_count_buffer(&self, frame: Frame) -> (&Buffer, usize) {
        match &self.buffers {
            DrawBinBuffers::CpuDriven { counts, .. } => {
                (counts, self.last_draw_call_buffer_idx(frame))
            }
            DrawBinBuffers::GpuDriven { counts, .. } => {
                (counts, self.last_draw_call_buffer_idx(frame))
            }
        }
    }

    #[inline(always)]
    fn draw_call_buffer(&self, frame: Frame) -> (&Buffer, usize) {
        match &self.buffers {
            DrawBinBuffers::CpuDriven { draw_calls, .. } => {
                (draw_calls, self.draw_call_buffer_idx(frame))
            }
            DrawBinBuffers::GpuDriven { dst_draw_calls, .. } => {
                (dst_draw_calls, self.draw_call_buffer_idx(frame))
            }
        }
    }

    #[inline(always)]
    fn last_draw_call_buffer(&self, frame: Frame) -> (&Buffer, usize) {
        match &self.buffers {
            DrawBinBuffers::CpuDriven { draw_calls, .. } => {
                (draw_calls, self.last_draw_call_buffer_idx(frame))
            }
            DrawBinBuffers::GpuDriven { dst_draw_calls, .. } => {
                (dst_draw_calls, self.last_draw_call_buffer_idx(frame))
            }
        }
    }

    pub fn preallocate_draw_call_buffers(&mut self, draw_call_count: usize) {
        let req_size = (draw_call_count * std::mem::size_of::<GpuDrawCall>()) as u64;
        match &mut self.buffers {
            DrawBinBuffers::CpuDriven { draw_calls, .. } => {
                if let Some(new_buff) = Buffer::expand(draw_calls, req_size, true) {
                    *draw_calls = new_buff;
                }
            }
            DrawBinBuffers::GpuDriven {
                src_draw_calls,
                dst_draw_calls,
                ..
            } => {
                if let Some(new_buff) = Buffer::expand(src_draw_calls, req_size, true) {
                    *src_draw_calls = new_buff;
                }
                if let Some(new_buff) = Buffer::expand(dst_draw_calls, req_size, false) {
                    *dst_draw_calls = new_buff;
                }
            }
        }
    }

    /// Generates high-z culling bins.
    pub fn gen_bins<'a, 'b, const FIF: usize>(
        &'b mut self,
        frame: Frame,
        highz_draws: impl Iterator<Item = &'a DrawGroup>,
        non_transparent_draws: impl Iterator<Item = &'a DrawGroup>,
        transparent_draws: impl Iterator<Item = &'a DrawGroup>,
        meshes: &'a ResourceAllocator<MeshResource, FIF>,
        materials: &'a ResourceAllocator<MaterialResource, FIF>,
    ) {
        // Switch to alternate buffer
        self.use_alternate_draw_buffer[usize::from(frame)] =
            !self.use_alternate_draw_buffer[usize::from(frame)];
        let draw_call_idx = self.draw_call_buffer_idx(frame);

        // Pull the view for the buffer
        let (mut draw_call_view, gpu_driven) = match &mut self.buffers {
            DrawBinBuffers::CpuDriven { draw_calls, .. } => {
                (draw_calls.write(draw_call_idx).unwrap(), false)
            }
            DrawBinBuffers::GpuDriven { src_draw_calls, .. } => {
                (src_draw_calls.write(usize::from(frame)).unwrap(), true)
            }
        };
        let draw_call_slice =
            bytemuck::cast_slice_mut::<_, GpuDrawCall>(draw_call_view.deref_mut());

        // Grab bin set and reset
        let bin_set = &mut self.bins[draw_call_idx];
        bin_set.bins.clear();

        // Generate high-z bins first
        bin_set.highz_rng.start = 0;
        bin_set.non_transparent_rng.start = 0;
        let highz_res = Self::gen_bins_inner(
            &mut bin_set.bins,
            highz_draws.zip(draw_call_slice.iter_mut()),
            meshes,
            materials,
            gpu_driven,
            0,
            0,
        );
        bin_set.highz_rng.end = highz_res.bin_count;

        // Generate non-transparent bins next (we skip the high-z draws since they're already
        // generated)
        let nt_res = Self::gen_bins_inner(
            &mut bin_set.bins,
            non_transparent_draws
                .zip(draw_call_slice.iter_mut())
                .skip(highz_res.draw_count),
            meshes,
            materials,
            gpu_driven,
            highz_res.draw_count,
            highz_res.object_count,
        );
        bin_set.non_transparent_rng.end = highz_res.bin_count + nt_res.bin_count;

        // Generate transparent bins last (we force this to be non gpu-driven because we can't make
        // draw call ordering guarantees using GPU atomics)
        bin_set.transparent_rng.start = bin_set.non_transparent_rng.end;
        let t_res = Self::gen_bins_inner(
            &mut bin_set.bins,
            transparent_draws.zip(
                draw_call_slice
                    .iter_mut()
                    .skip(highz_res.draw_count + nt_res.draw_count),
            ),
            meshes,
            materials,
            // We force non-GPU driven because we don't want draw compaction to reorder
            // transparent draws.
            false,
            highz_res.draw_count + nt_res.draw_count,
            highz_res.object_count + nt_res.object_count,
        );
        bin_set.transparent_rng.end = bin_set.transparent_rng.start + t_res.bin_count;

        // Generate draw counts
        std::mem::drop(draw_call_view);
        self.gen_draw_count(frame);
    }

    /// Appends bins from the provided grouped draws.
    fn gen_bins_inner<'a, 'b, const FIF: usize>(
        bins: &mut Vec<DrawBin>,
        grouped_draws: impl Iterator<Item = (&'a DrawGroup, &'b mut GpuDrawCall)>,
        meshes: &ResourceAllocator<MeshResource, FIF>,
        materials: &ResourceAllocator<MaterialResource, FIF>,
        gpu_driven: bool,
        mut draw_call_offset: usize,
        mut object_id_offset: usize,
    ) -> BinGenOutput {
        let mut out = BinGenOutput {
            draw_count: 0,
            object_count: 0,
            bin_count: 0,
        };

        // State tracking to generate bins
        let mut state = RenderStateTracker::default();
        let mut draw_count: usize = 0;
        let mut delta = BindingDelta::default();
        let mut first = true;

        // Generate bins for all groups
        for (group, draw_call) in grouped_draws {
            let separated_key = group.key.separate();

            // If this is the first group, we must prime the delta
            // TODO: Get this check out of the hot loop
            if first {
                delta = state.compute_delta(&separated_key, meshes, materials);
                first = false;
            }

            // Compute the delta for this draw and see if it's new
            let new_delta = state.compute_delta(&separated_key, meshes, materials);

            // If it is, we submit the current group
            if new_delta.draw_required() {
                bins.push(DrawBin {
                    count: draw_count,
                    offset: draw_call_offset,
                    skip: delta.skip,
                    material: delta.new_material,
                    vertices: delta.new_vertices,
                    data_size: delta.new_data_size,
                });

                draw_call_offset += draw_count;
                out.bin_count += 1;
                draw_count = 0;

                delta = new_delta;
            }

            // Write the draw call for this group
            let first_instance = object_id_offset as u32;
            object_id_offset += group.len;
            out.object_count += group.len;

            *draw_call = match meshes.get(separated_key.mesh_id) {
                Some(mesh) => GpuDrawCall {
                    index_count: mesh.index_count as u32,
                    instance_count: if gpu_driven { 0 } else { group.len as u32 },
                    first_index: mesh.block.index_block().base(),
                    vertex_offset: mesh.block.vertex_block().base() as i32,
                    first_instance,
                    draw_bin: bins.len() as u32,
                    bin_offset: draw_count as u32,
                    bounds: GpuObjectBounds {
                        center: mesh.bounds.center,
                        half_extents: mesh.bounds.half_extents,
                    },
                },
                None => {
                    warn!(
                        "Attempted to render mesh with ID `{:?}` that did not exist. Skipping draw.",
                        separated_key.mesh_id,
                    );
                    GpuDrawCall {
                        index_count: 0,
                        instance_count: 0,
                        first_index: 0,
                        vertex_offset: 0,
                        first_instance: 0,
                        draw_bin: 0,
                        bin_offset: 0,
                        bounds: GpuObjectBounds {
                            center: Vec4::ZERO,
                            half_extents: Vec4::ZERO,
                        },
                    }
                }
            };

            draw_count += 1;
            out.draw_count += 1;
        }

        // Add in the final draw if it wasn't registered
        if draw_count > 0 {
            bins.push(DrawBin {
                count: draw_count,
                offset: draw_call_offset,
                skip: delta.skip,
                material: delta.new_material,
                vertices: delta.new_vertices,
                data_size: delta.new_data_size,
            });
            out.bin_count += 1;
        }

        out
    }

    fn gen_draw_count(&mut self, frame: Frame) {
        let idx = self.draw_call_buffer_idx(frame);
        let (counts_buffer, _gpu_driven) = match &mut self.buffers {
            DrawBinBuffers::CpuDriven { counts, .. } => (counts, false),
            DrawBinBuffers::GpuDriven { counts, .. } => (counts, true),
        };

        let count_buffer_size = (self.bins[idx].bins.len() * std::mem::size_of::<u32>() * 2) as u64;
        if let Some(buffer) = Buffer::expand(counts_buffer, count_buffer_size, false) {
            *counts_buffer = buffer;
        }
        let mut count_view = counts_buffer.write(idx).unwrap();
        let count_slice = bytemuck::cast_slice_mut::<_, u32>(count_view.deref_mut());

        for (i, bin) in self.bins[idx].bins.iter().enumerate() {
            count_slice[i * 2] = 0;
            count_slice[(i * 2) + 1] = bin.offset as u32;
        }
    }

    #[inline(always)]
    fn draw_call_buffer_idx(&self, frame: Frame) -> usize {
        let frame = usize::from(frame);
        (frame * 2) + self.use_alternate_draw_buffer[frame] as usize
    }

    #[inline(always)]
    fn last_draw_call_buffer_idx(&self, frame: Frame) -> usize {
        let frame = usize::from(frame);
        (frame * 2) + !self.use_alternate_draw_buffer[frame] as usize
    }

    pub fn render_highz_bins<'a, const FIF: usize>(&'a self, args: RenderArgs<'a, '_, FIF>) {
        let idx = self.draw_call_buffer_idx(args.frame);
        let set = &self.bins[idx];
        let draw_calls = self.last_draw_call_buffer(args.frame);
        let draw_counts = self.last_draw_count_buffer(args.frame);
        self.render_bins(
            args,
            draw_calls,
            draw_counts,
            set.highz_rng.start,
            set.highz_rng.len(),
        );
    }

    pub fn render_non_transparent_bins<'a, const FIF: usize>(
        &'a self,
        args: RenderArgs<'a, '_, FIF>,
    ) {
        let idx = self.draw_call_buffer_idx(args.frame);
        let set = &self.bins[idx];
        let draw_calls = self.draw_call_buffer(args.frame);
        let draw_counts = self.draw_counts_buffer(args.frame);
        self.render_bins(
            args,
            draw_calls,
            draw_counts,
            set.non_transparent_rng.start,
            set.non_transparent_rng.len(),
        );
    }

    pub fn render_transparent_bins<'a, const FIF: usize>(&'a self, args: RenderArgs<'a, '_, FIF>) {
        let idx = self.draw_call_buffer_idx(args.frame);
        let set = &self.bins[idx];
        let draw_calls = self.draw_call_buffer(args.frame);
        let draw_counts = self.draw_counts_buffer(args.frame);
        self.render_bins(
            args,
            draw_calls,
            draw_counts,
            set.transparent_rng.start,
            set.transparent_rng.len(),
        );
    }

    fn render_bins<'a, const FIF: usize>(
        &'a self,
        args: RenderArgs<'a, '_, FIF>,
        draw_calls: (&'a Buffer, usize),
        draw_counts: (&'a Buffer, usize),
        bin_offset: usize,
        bin_count: usize,
    ) {
        let idx = self.draw_call_buffer_idx(args.frame);
        let mut mat_vertex_layout = VertexLayout::empty();
        let mut mesh_vertex_layout = VertexLayout::empty();
        let mut mat_id = ResourceId::from(usize::MAX);
        let mut variant_id = u32::MAX;

        for (bin_idx, bin) in self.bins[idx]
            .bins
            .iter()
            .enumerate()
            .skip(bin_offset)
            .take(bin_count)
        {
            // Pre-check for meshes vertex layout because it's needed by the material
            if let Some(vertex_layout) = bin.vertices {
                mesh_vertex_layout = vertex_layout;
            }

            // Perform rebindings
            let mut rebound_material = false;
            if let Some(new_mat_id) = bin.material {
                mat_id = new_mat_id;

                let mat = args.materials.get(mat_id).unwrap();
                let variant = match mat.get_variant(MaterialVariantRequest {
                    pass_id: args.pass_id,
                    vertex_layout: mesh_vertex_layout,
                }) {
                    Some(variant) => variant,
                    None => panic!(
                        "Attempt to render with material `{:?}` with vertex layout \
                    `{:?}` but there were no supported variants.",
                        mat_id, mesh_vertex_layout
                    ),
                };

                variant_id = variant.id;
                mat_vertex_layout = variant.vertex_layout;

                // Bind variant pipeline
                args.pass.bind_pipeline(variant.pipeline.clone());
                rebound_material = true;

                // Bind global sets
                args.pass.bind_sets(
                    0,
                    vec![
                        args.global.get_set(args.frame),
                        args.texture_factory.get_set(args.frame),
                        args.camera.get_set(args.frame),
                    ],
                );
            }

            if let Some(data_size) = bin.data_size {
                if data_size > 0 {
                    // Bind material set
                    args.pass.bind_sets(
                        3,
                        vec![args
                            .material_factory
                            .get_set(args.frame, data_size as u64)
                            .unwrap()],
                    );
                }
            }

            if let Some(vertex_layout) = bin.vertices {
                // If the vertices have changed, we also must check if the shader variant has
                // changed, but only if the pipeline was not rebound
                if !rebound_material {
                    let mat = args.materials.get(mat_id).unwrap();
                    let variant = match mat.get_variant(MaterialVariantRequest {
                        pass_id: args.pass_id,
                        vertex_layout: mesh_vertex_layout,
                    }) {
                        Some(variant) => variant,
                        None => panic!(
                            "Attempt to render with material `{:?}` with vertex layout \
                        `{:?}` but there were no supported variants.",
                            mat_id, mesh_vertex_layout
                        ),
                    };

                    if variant.id != variant_id {
                        variant_id = variant.id;
                        mat_vertex_layout = variant.vertex_layout;

                        // Bind variant pipeline
                        args.pass.bind_pipeline(variant.pipeline.clone());

                        // Bind global sets
                        args.pass.bind_sets(
                            0,
                            vec![
                                args.global.get_set(args.frame),
                                args.texture_factory.get_set(args.frame),
                                args.camera.get_set(args.frame),
                            ],
                        );
                    }
                }

                // NOTE: Vertex buffer type must exist if we have a valid mesh that uses it's layout
                mesh_vertex_layout = vertex_layout;
                let vbuffer = args.mesh_factory.get_vertex_buffer(vertex_layout).unwrap();
                vbuffer.bind(args.pass, mat_vertex_layout).unwrap();
            }

            // Skip if requested
            if bin.skip {
                continue;
            }

            // Perform the draw call
            args.pass.draw_indexed_indirect_count(
                draw_calls.0,
                draw_calls.1,
                (bin.offset * std::mem::size_of::<GpuDrawCall>()) as u64,
                draw_counts.0,
                draw_counts.1,
                (bin_idx * 2 * std::mem::size_of::<u32>()) as u64,
                bin.count,
                std::mem::size_of::<GpuDrawCall>() as u64,
            );
        }
    }
}
