use ard_formats::mesh::VertexLayout;
use ard_log::warn;
use ard_math::{Vec2, Vec4};
use ard_pal::prelude::*;

use crate::factory::{
    allocator::{EscapeHandle, ResourceId},
    meshes::{MeshBlock, MeshBuffers},
};

#[derive(Clone)]
pub struct Mesh {
    pub(crate) id: ResourceId,
    pub(crate) layout: VertexLayout,
    pub(crate) _escaper: EscapeHandle,
}

pub(crate) struct MeshInner {
    pub layout: VertexLayout,
    pub bounds: ObjectBounds,
    pub vertex_block: MeshBlock,
    pub index_block: MeshBlock,
    pub index_count: usize,
    pub vertex_count: usize,
    /// Indicates that the mesh buffers have been uploaded and the mesh is ready to be used.
    pub ready: bool,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum AttributeType {
    Position,
    Normal,
    Tangent,
    Color,
    Uv0,
    Uv1,
    Uv2,
    Uv3,
}

/// Volume bounded by the dimensions of a box and sphere.
#[derive(Debug, Default, Copy, Clone)]
#[repr(C)]
pub struct ObjectBounds {
    /// `w` component of `center` should be a bounding sphere radius.
    pub center: Vec4,
    pub half_extents: Vec4,
}

#[derive(Default)]
pub struct MeshCreateInfo<'a> {
    pub bounds: MeshBounds,
    pub indices: &'a [u32],
    pub vertices: Vertices<'a>,
}

pub enum Vertices<'a> {
    Attributes {
        positions: &'a [Vec4],
        /// If `Some`, must be the same length as `positions`.
        normals: Option<&'a [Vec4]>,
        /// If `Some`, must be the same length as `positions`.
        tangents: Option<&'a [Vec4]>,
        /// If `Some`, must be the same length as `positions`.
        colors: Option<&'a [Vec4]>,
        /// If `Some`, must be the same length as `positions`.
        uv0: Option<&'a [Vec2]>,
        /// If `Some`, must be the same length as `positions`.
        uv1: Option<&'a [Vec2]>,
        /// If `Some`, must be the same length as `positions`.
        uv2: Option<&'a [Vec2]>,
        /// If `Some`, must be the same length as `positions`.
        uv3: Option<&'a [Vec2]>,
    },
    Combined {
        layout: VertexLayout,
        count: usize,
        data: &'a [u8],
    },
}

/// Object bounds for a mesh.
#[derive(Debug, Copy, Clone)]
pub enum MeshBounds {
    /// Manually set the bounds.
    Manual(ObjectBounds),
    /// Bounds are autogenerated from the positions list.
    Generate,
}

impl MeshInner {
    pub fn new(
        ctx: &Context,
        mesh_buffers: &mut MeshBuffers,
        create_info: MeshCreateInfo,
    ) -> (Self, Buffer, Buffer) {
        assert!(!create_info.indices.is_empty());

        let layout = create_info.vertex_layout();
        let (vertex_count, vb_staging) = match &create_info.vertices {
            Vertices::Attributes {
                positions,
                normals,
                tangents,
                colors,
                uv0,
                uv1,
                uv2,
                uv3,
            } => {
                let vertex_count = positions.len();

                // Create vertex staging buffer
                let mut vb_data = Vec::<u8>::default();
                vb_data.extend_from_slice(bytemuck::cast_slice(positions));

                if let Some(normals) = normals {
                    vb_data.extend_from_slice(bytemuck::cast_slice(normals));
                }

                if let Some(tangents) = tangents {
                    vb_data.extend_from_slice(bytemuck::cast_slice(tangents));
                }

                if let Some(colors) = colors {
                    vb_data.extend_from_slice(bytemuck::cast_slice(colors));
                }

                if let Some(uv0) = uv0 {
                    vb_data.extend_from_slice(bytemuck::cast_slice(uv0));
                }

                if let Some(uv1) = uv1 {
                    vb_data.extend_from_slice(bytemuck::cast_slice(uv1));
                }

                if let Some(uv2) = uv2 {
                    vb_data.extend_from_slice(bytemuck::cast_slice(uv2));
                }

                if let Some(uv3) = uv3 {
                    vb_data.extend_from_slice(bytemuck::cast_slice(uv3));
                }

                let vb_staging = Buffer::new_staging(
                    ctx.clone(),
                    Some(String::from("vertex_staging")),
                    &vb_data,
                )
                .unwrap();

                (vertex_count, vb_staging)
            }
            Vertices::Combined { count, data, .. } => {
                let vb_staging =
                    Buffer::new_staging(ctx.clone(), Some(String::from("vertex_staging")), data)
                        .unwrap();
                (*count, vb_staging)
            }
        };

        // Create index staging buffer
        let mut ib_data =
            Vec::<u8>::with_capacity(std::mem::size_of::<u32>() * create_info.indices.len());
        ib_data.extend_from_slice(bytemuck::cast_slice(create_info.indices));
        let ib_staging =
            Buffer::new_staging(ctx.clone(), Some(String::from("index_staging")), &ib_data)
                .unwrap();

        // Allocate block for vertex data
        let vbs = mesh_buffers.get_vertex_buffer_mut(layout);
        let vertex_block = match vbs.allocate(vertex_count) {
            Some(block) => block,
            // Not enough room we mut expand the buffer
            None => {
                warn!("Vertex buffer expanded. Consider making the default size larger.");
                vbs.expand_for(ctx, vertex_count);
                vbs.allocate(vertex_count).unwrap()
            }
        };

        // Allocate block for index data
        let ib = mesh_buffers.get_index_buffer_mut();
        let index_block = match ib.allocate(create_info.indices.len()) {
            Some(block) => block,
            // Not enough room we mut expand the buffer
            None => {
                warn!("Index buffer expanded. Consider making the default size larger.");
                ib.expand_for(ctx, create_info.indices.len());
                ib.allocate(create_info.indices.len()).unwrap()
            }
        };

        (
            MeshInner {
                layout,
                vertex_block,
                index_block,
                index_count: create_info.indices.len(),
                vertex_count,
                bounds: create_info.bounds(),
                ready: false,
            },
            vb_staging,
            ib_staging,
        )
    }
}

impl<'a> MeshCreateInfo<'a> {
    /// Get the bounds for the positions contained.
    pub fn bounds(&self) -> ObjectBounds {
        if let MeshBounds::Manual(bounds) = self.bounds {
            bounds
        } else {
            let positions = match &self.vertices {
                Vertices::Attributes { positions, .. } => *positions,
                Vertices::Combined { count, data, .. } => {
                    bytemuck::cast_slice(&data[0..(count * std::mem::size_of::<Vec4>())])
                }
            };

            if positions.is_empty() {
                return ObjectBounds::default();
            }

            let mut min = positions[0];
            let mut max = positions[0];
            let mut sqr_radius = min.x.powi(2) + min.z.powi(2) + min.y.powi(2);

            for position in positions {
                let new_sqr_radius = position.x.powi(2) + position.z.powi(2) + position.y.powi(2);

                if new_sqr_radius > sqr_radius {
                    sqr_radius = new_sqr_radius;
                }

                if position.x < min.x {
                    min.x = position.x;
                }

                if position.y < min.y {
                    min.y = position.y;
                }

                if position.z < min.z {
                    min.z = position.z;
                }

                if position.x > max.x {
                    max.x = position.x;
                }

                if position.y > max.y {
                    max.y = position.y;
                }

                if position.z > max.z {
                    max.z = position.z;
                }
            }

            ObjectBounds {
                center: Vec4::new(
                    (max.x + min.x) / 2.0,
                    (max.y + min.y) / 2.0,
                    (max.z + min.z) / 2.0,
                    sqr_radius.sqrt(),
                ),
                half_extents: Vec4::new(
                    (max.x - min.x) / 2.0,
                    (max.y - min.y) / 2.0,
                    (max.z - min.z) / 2.0,
                    1.0,
                ),
            }
        }
    }

    #[inline(always)]
    pub fn vertex_layout(&self) -> VertexLayout {
        match &self.vertices {
            Vertices::Attributes {
                normals,
                tangents,
                colors,
                uv0,
                uv1,
                uv2,
                uv3,
                ..
            } => {
                let mut layout = VertexLayout::empty();
                if normals.is_some() {
                    layout |= VertexLayout::NORMAL;
                }
                if tangents.is_some() {
                    layout |= VertexLayout::TANGENT;
                }
                if colors.is_some() {
                    layout |= VertexLayout::COLOR;
                }
                if uv0.is_some() {
                    layout |= VertexLayout::UV0;
                }
                if uv1.is_some() {
                    layout |= VertexLayout::UV1;
                }
                if uv2.is_some() {
                    layout |= VertexLayout::UV2;
                }
                if uv3.is_some() {
                    layout |= VertexLayout::UV3;
                }
                layout
            }
            Vertices::Combined { layout, .. } => *layout,
        }
    }
}

impl Default for MeshBounds {
    #[inline(always)]
    fn default() -> Self {
        MeshBounds::Manual(ObjectBounds::default())
    }
}

impl<'a> Default for Vertices<'a> {
    fn default() -> Self {
        Vertices::Combined {
            layout: VertexLayout::empty(),
            count: 0,
            data: &[],
        }
    }
}
