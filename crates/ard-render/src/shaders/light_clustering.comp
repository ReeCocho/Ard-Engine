#version 450
#extension GL_EXT_control_flow_attributes: enable

#include "data_structures.glsl"

layout(local_size_x_id = 0) in;
layout(local_size_y_id = 1) in;
layout(local_size_z_id = 2) in;

layout(set = 0, binding = 0) readonly restrict buffer ARD_Lights {
    Light[] lights;
};

layout(set = 0, binding = 1) restrict buffer ARD_Clusters {
    LightClusters light_clusters;
};

layout(set = 0, binding = 2) uniform ARD_Camera {
    Camera camera;
};

layout(set = 0, binding = 3) readonly restrict buffer ARD_CameraFroxels {
    CameraFroxels clusters;
};

layout(push_constant) uniform constants {
    uint total_lights;
};

void main() {
    Froxel froxel = clusters.froxels
        [gl_WorkGroupID.z]
        [gl_LocalInvocationID.x]
        [gl_LocalInvocationID.y];

    uint light_idx = 0;
    for (int i = 0; i < total_lights; i++) {
        // Bounds check for lights
        if (light_idx >= MAX_LIGHTS_PER_FROXEL) {
            break;
        }

        // Convert light position to view space
        vec4 light_pos_rng = lights[i].position_range;
        vec4 pos = camera.view * vec4(light_pos_rng.xyz, 1.0);

        // Z-slice check
        vec2 min_max_z = froxel.min_max_z.xy;
        if (pos.z - light_pos_rng.w > min_max_z.y || pos.z + light_pos_rng.w < min_max_z.x) {
            continue;
        }

        // Check planes
        bool inside = true;

        [[unroll]]
        for (int i = 0; i < 4; i++) {
            if (dot(pos, froxel.planes[i]) <= -light_pos_rng.w) {
                inside = false;
                break;
            }
        }

        if (!inside) {
            continue;
        }

        // Add light to cluster
        light_clusters.clusters
            [gl_WorkGroupID.z]
            [gl_LocalInvocationID.x]
            [gl_LocalInvocationID.y]
            [light_idx] = i;
        light_idx += 1;
    }

    // Set light count
    light_clusters.light_counts
        [gl_WorkGroupID.z]
        [gl_LocalInvocationID.x]
        [gl_LocalInvocationID.y] = light_idx;
}