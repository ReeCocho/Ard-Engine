#version 450
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_control_flow_attributes: enable

#include "data_structures.glsl"

layout(local_size_x_id = 0) in;
layout(local_size_y_id = 1) in;
layout(local_size_z_id = 2) in;

/// Draw calls to update the draw count of when an object is verified for rendering. Also contains
/// bounding volume information for objects of the type it draws.
layout(set = 0, binding = 0) restrict buffer DrawCalls {
    DrawCall[] draw_calls;
};

/// Contains per object information.
layout(set = 0, binding = 1) restrict readonly buffer Objects {
    ObjectData[] objects;
};

/// Input objects to verify for rendering.
layout(set = 0, binding = 2) restrict readonly buffer InputIds {
    ObjectId[] input_ids;
};

/// Output indices into the `objects` buffer for verified objects.
layout(set = 0, binding = 3) restrict writeonly buffer OutputIds {
    uint[] output_ids;
};

/// Camera to use from frustum/high-z culling.
layout(set = 0, binding = 4) uniform CameraUbo {
    Camera camera;
};

// HZB image for occlusion culling.
layout(set = 0, binding = 5) uniform sampler2D hzb_image; 

layout(push_constant) uniform constants {
    vec2 render_area;
    uint object_count;
};

/// Transforms the bounding box via the given model matrix.
BoundingBox transform_bounding_box(mat4 model, vec4 center, vec4 half_extents) {
    BoundingBox bb;

    half_extents.x = max(half_extents.x + 0.1, 0.1);
    half_extents.y = max(half_extents.y + 0.1, 0.1);
    half_extents.z = max(half_extents.z + 0.1, 0.1);

    // Compute all eight corners
    mat4 vm = camera.view * model;
    bb.corners[0] = vm * vec4(center.xyz + vec3(+half_extents.x, +half_extents.y, +half_extents.z), 1.0);
    bb.corners[1] = vm * vec4(center.xyz + vec3(-half_extents.x, +half_extents.y, +half_extents.z), 1.0);
    bb.corners[2] = vm * vec4(center.xyz + vec3(-half_extents.x, -half_extents.y, +half_extents.z), 1.0);
    bb.corners[3] = vm * vec4(center.xyz + vec3(-half_extents.x, +half_extents.y, -half_extents.z), 1.0);
    bb.corners[4] = vm * vec4(center.xyz + vec3(+half_extents.x, -half_extents.y, -half_extents.z), 1.0);
    bb.corners[5] = vm * vec4(center.xyz + vec3(+half_extents.x, -half_extents.y, +half_extents.z), 1.0);
    bb.corners[6] = vm * vec4(center.xyz + vec3(+half_extents.x, +half_extents.y, -half_extents.z), 1.0);
    bb.corners[7] = vm * vec4(center.xyz + vec3(-half_extents.x, -half_extents.y, -half_extents.z), 1.0);

    // Then find the min and max points in screen space
    bb.min_pt = vec2(uintBitsToFloat(0x7F800000));
    bb.max_pt = vec2(uintBitsToFloat(0xFF800000));
    bb.depth = uintBitsToFloat(0x7F800000);

    [[unroll]]
    for (int i = 0; i < 8; i++) {
        // Depth
        bb.depth = min(bb.depth, bb.corners[i].z);
    
        bb.corners[i] = camera.projection * bb.corners[i];
        bb.corners[i] /= bb.corners[i].w;
        vec4 pt = bb.corners[i];

        // Min
        bb.min_pt.x = min(bb.min_pt.x, pt.x);
        bb.min_pt.y = min(bb.min_pt.y, pt.y);

        // Max
        bb.max_pt.x = max(bb.max_pt.x, pt.x);
        bb.max_pt.y = max(bb.max_pt.y, pt.y);
    }

    return bb;
}

void main() {
    uint object_index = gl_GlobalInvocationID.x;
    if (object_index >= object_count) {
        return;
    }

    // Grab the object
    ObjectId obj = input_ids[object_index];
    mat4 model = objects[obj.data_idx].model;

    // Frustum culling using sphere radius
    vec4 bounds_center = draw_calls[obj.draw_idx].bounds_center;
    vec4 pos = model * vec4(bounds_center.xyz, 1.0);
    vec3 scale = vec3(
        dot(model[0].xyz, model[0].xyz),
        dot(model[1].xyz, model[1].xyz),
        dot(model[2].xyz, model[2].xyz)
    );
    float radius = bounds_center.w * sqrt(max(scale.x, max(scale.y, scale.z)));

    [[unroll]]
    for (int i = 0; i < 6; i++) { 
        if (dot(vec4(pos.xyz, 1.0), camera.frustum.planes[i]) < -radius) {
            return;
        }
    }

#if defined(HIGH_Z_CULLING)
    // Find the AABB of the object
    BoundingBox bb = transform_bounding_box(
        model, 
        bounds_center, 
        draw_calls[obj.draw_idx].bounds_half_extents
    );

    // Determine the appropriate mip level to sample the HZB image
    vec2 dbl_pixel_size = vec2(
        bb.max_pt.x - bb.min_pt.x,
        bb.max_pt.y - bb.min_pt.y
    ) * render_area;
    float level = floor(log2(max(dbl_pixel_size.x, dbl_pixel_size.y) * 0.5));
    
    // Clip space to UV
    bb.max_pt = (bb.max_pt * 0.5) + vec2(0.5);
    bb.max_pt.y = 1.0 - bb.max_pt.y;

    bb.min_pt = (bb.min_pt * 0.5) + vec2(0.5);
    bb.min_pt.y = 1.0 - bb.min_pt.y;

    // Determine depth (in world space)
    float depth = textureLod(hzb_image, (bb.max_pt + bb.min_pt) * 0.5, level).x;
    depth = camera.near_clip / depth;

    // If our object is behind all local objects, cull
    if (bb.depth > depth) {
        return;
    }
#endif

    // Insert the object into the output list and notify the associated call of the object
    uint model_offset = atomicAdd(draw_calls[obj.draw_idx].instance_count, 1);
    uint instance_index = draw_calls[obj.draw_idx].first_instance + model_offset;
    output_ids[instance_index] = obj.data_idx;
}