// Compile with:
// glslc point_light_gen.comp --target-env=vulkan1.2 -o point_light_gen.comp.spv
#version 450

layout(local_size_x_id = 0) in;

#define TABLE_X 32
#define TABLE_Y 16
#define TABLE_Z 16
#define MAX_POINT_LIGHTS 256

struct PointLight {
    vec4 color_intensity;
    vec4 position_range;
};

layout(set = 0, binding = 0) readonly buffer PointLights {
    PointLight[] lights;
};

layout(set = 0, binding = 1) buffer PointLightTable {
    int[TABLE_X][TABLE_Y][TABLE_Z] light_counts;
    uint[TABLE_X][TABLE_Y][TABLE_Z][MAX_POINT_LIGHTS] clusters; 
};

layout(set = 0, binding = 2) uniform sampler2D depth_pyramid;

layout(set = 1, binding = 0) uniform CameraUBO {
    mat4 view;
    mat4 projection;
    mat4 vp;
    mat4 view_inv;
    mat4 projection_inv;
    mat4 vp_inv;
    vec4[6] planes;
    vec4 properties;
    vec4 position;
} camera;

layout(push_constant) uniform constants {
    vec2 render_area;
    uint total_lights;
};

void main() {
    uint light_index = gl_GlobalInvocationID.x;
    if (light_index >= total_lights) {
        return;
    }

    PointLight light = lights[light_index];

    // Frustum culling
    vec4 pos = vec4(light.position_range.xyz, 1.0);
    float radius = light.position_range.w;
    for (int i = 0; i < 6; i++) { 
        if (dot(pos, camera.planes[i]) <= -radius) {
            return;
        }
    }

    // Convert light position to view space
    pos = camera.view * pos;

    // Check each cluster to see if the light touches it
    for (int x = 0; x < TABLE_X; x++) {
        for (int y = 0; y < TABLE_Y; y++) {
            for (int z = 0; z < TABLE_Z; z++) {
                // Find min and max point of the cluster in screen space
                float near = pow(2.0, float(z) / float(TABLE_Z)) - 1.0;
                float far = pow(2.0, float(z + 1) / float(TABLE_Z)) - 1.0;

                vec4 cluster_min_ss = vec4(
                    ((float(x) / float(TABLE_X)) * 2.0) - 1.0,
                    ((float(y) / float(TABLE_Y)) * 2.0) - 1.0,
                    near,
                    1.0
                );

                vec4 cluster_max_ss = vec4(
                    ((float(x + 1) / float(TABLE_X)) * 2.0) - 1.0,
                    ((float(y + 1) / float(TABLE_Y)) * 2.0) - 1.0,
                    far,
                    1.0
                );

                // Finding the 4 intersection points made from each point to the cluster near/far plane
                vec4 min_point_near = camera.projection_inv * cluster_min_ss;
                vec4 min_point_far  = camera.projection_inv * vec4(cluster_min_ss.xy, far, 1.0);
                vec4 max_point_near = camera.projection_inv * cluster_max_ss;
                vec4 max_point_far  = camera.projection_inv * vec4(cluster_max_ss.xy, far, 1.0);

                min_point_near /= min_point_near.w;
                min_point_far /= min_point_far.w;
                max_point_near /= max_point_near.w;
                max_point_far /= max_point_far.w;

                // Min and max bounding area
                vec3 min_point_AABB = min(min(min_point_near.xyz, min_point_far.xyz), min(max_point_near.xyz, max_point_far.xyz));
                vec3 max_point_AABB = max(max(min_point_near.xyz, min_point_far.xyz), max(max_point_near.xyz, max_point_far.xyz));
                
                // Compute square distance from light to cluster volume
                float sq_dist = radius * radius;
                
                if (pos.x < min_point_AABB.x) sq_dist -= pow(pos.x - min_point_AABB.x, 2.0);
                else if (pos.x > max_point_AABB.x) sq_dist -= pow(pos.x - max_point_AABB.x, 2.0);
                if (pos.y < min_point_AABB.y) sq_dist -= pow(pos.y - min_point_AABB.y, 2.0);
                else if (pos.y > max_point_AABB.y) sq_dist -= pow(pos.y - max_point_AABB.y, 2.0);
                if (pos.z < min_point_AABB.z) sq_dist -= pow(pos.z - min_point_AABB.z, 2.0);
                else if (pos.z > max_point_AABB.z) sq_dist -= pow(pos.z - max_point_AABB.z, 2.0);

                if (sq_dist > 0.0) {
                    // Try to add to the cluster. Bail if it's full
                    uint light_idx = atomicAdd(light_counts[x][y][z], 1);

                    if (light_idx >= MAX_POINT_LIGHTS) {
                        atomicAdd(light_counts[x][y][z], -1);
                        return;
                    }

                    clusters[x][y][z][light_idx] = light_index;
                }
            }
        }
    }
}