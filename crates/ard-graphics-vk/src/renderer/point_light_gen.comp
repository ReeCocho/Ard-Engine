// Compile with:
// glslc point_light_gen.comp --target-env=vulkan1.2 -o point_light_gen.comp.spv
#version 450

layout(local_size_x_id = 0) in;

#define TABLE_X 32
#define TABLE_Y 16
#define TABLE_Z 16
#define MAX_POINT_LIGHTS 256

struct PointLight {
    vec4 color_intensity;
    vec4 position_range;
};

struct Froxel {
    vec4[4] planes;
    vec4 min_max_z;
};

layout(set = 0, binding = 0) readonly buffer PointLights {
    PointLight[] lights;
};

layout(set = 0, binding = 1) buffer PointLightTable {
    int[TABLE_X][TABLE_Y][TABLE_Z] light_counts;
    uint[TABLE_X][TABLE_Y][TABLE_Z][MAX_POINT_LIGHTS] clusters; 
};

layout(set = 0, binding = 2) uniform sampler2D depth_pyramid;

layout(set = 1, binding = 0) uniform CameraUBO {
    mat4 view;
    mat4 projection;
    mat4 vp;
    mat4 view_inv;
    mat4 projection_inv;
    mat4 vp_inv;
    vec4[6] planes;
    vec4 properties;
    vec4 position;
    vec2 scale_bias;
} camera;

layout(set = 1, binding = 1) readonly buffer Clusters {
    Froxel data[TABLE_X][TABLE_Y][TABLE_Z];
} cluster_froxels;

layout(push_constant) uniform constants {
    vec2 render_area;
    uint total_lights;
};

void main() {
    uint light_index = gl_GlobalInvocationID.x;
    if (light_index >= total_lights) {
        return;
    }

    PointLight light = lights[light_index];

    // Frustum culling
    vec4 pos = vec4(light.position_range.xyz, 1.0);
    float radius = light.position_range.w;
    for (int i = 0; i < 6; i++) { 
        if (dot(pos, camera.planes[i]) <= -radius) {
            return;
        }
    }

    // Convert light position to view space
    pos = camera.view * pos;

    // Check each cluster to see if the light touches it
    for (int z = 0; z < TABLE_Z; z++) {
        // Check z slice. We do z first because we can skip entire slices if we are out of z bounds
        vec2 min_max_z = cluster_froxels.data[0][0][z].min_max_z.xy;
        if (pos.z - radius > min_max_z.y || pos.z + radius < min_max_z.x) {
            continue;
        }

        for (int x = 0; x < TABLE_X; x++) {
            for (int y = 0; y < TABLE_Y; y++) {
                // Check planes
                bool inside = true;
                for (int i = 0; i < 4; i++) {
                    if (dot(pos, cluster_froxels.data[x][y][z].planes[i]) <= -radius) {
                        inside = false;
                        break;
                    }
                }

                if (!inside) {
                    continue;
                }

                // Try to add to the cluster. Bail if it's full
                uint light_idx = atomicAdd(light_counts[x][y][z], 1);

                if (light_idx >= MAX_POINT_LIGHTS) {
                    atomicAdd(light_counts[x][y][z], -1);
                    return;
                }

                clusters[x][y][z][light_idx] = light_index;
            }
        }
    }
}