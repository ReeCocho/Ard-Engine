// Compile with:
// glslc point_light_gen.comp --target-env=vulkan1.2 -o point_light_gen.comp.spv
#version 450

layout(local_size_x_id = 0) in;
layout(local_size_y_id = 1) in;
layout(local_size_z_id = 2) in;

#define TABLE_X 32
#define TABLE_Y 16
#define TABLE_Z 16
#define MAX_POINT_LIGHTS 256

struct PointLight {
    vec4 color_intensity;
    vec4 position_range;
};

struct Froxel {
    vec4[4] planes;
    vec4 min_max_z;
};

layout(set = 0, binding = 0) readonly buffer PointLights {
    PointLight[] lights;
};

layout(set = 0, binding = 1) restrict buffer PointLightTable {
    int[TABLE_Z][TABLE_X][TABLE_Y] light_counts;
    uint[TABLE_Z][TABLE_X][TABLE_Y][MAX_POINT_LIGHTS] clusters; 
};

layout(set = 0, binding = 2) uniform sampler2D depth_pyramid;

layout(set = 1, binding = 0) uniform CameraUBO {
    mat4 view;
    mat4 projection;
    mat4 vp;
    mat4 view_inv;
    mat4 projection_inv;
    mat4 vp_inv;
    vec4[6] planes;
    vec4 properties;
    vec4 position;
    vec2 scale_bias;
} camera;

layout(set = 1, binding = 1) readonly buffer Clusters {
    Froxel data[TABLE_Z][TABLE_X][TABLE_Y];
} cluster_froxels;

layout(push_constant) uniform constants {
    vec2 render_area;
    uint total_lights;
};

void main() {
    Froxel froxel = cluster_froxels.data
        [gl_GlobalInvocationID.z]
        [gl_GlobalInvocationID.x]
        [gl_GlobalInvocationID.y];

    uint light_idx = 0;
    for (int i = 0; i < total_lights; i++) {
        // Bounds check for lights
        if (light_idx >= MAX_POINT_LIGHTS) {
            break;
        }

        PointLight light = lights[i];

        // Convert light position to view space
        float radius = light.position_range.w;
        vec4 pos = camera.view * vec4(light.position_range.xyz, 1.0);

        // Z-slice check
        vec2 min_max_z = froxel.min_max_z.xy;
        if (pos.z - radius > min_max_z.y || pos.z + radius < min_max_z.x) {
            continue;
        }

        // Check planes
        bool inside = true;
        for (int i = 0; i < 4; i++) {
            if (dot(pos, froxel.planes[i]) <= -radius) {
                inside = false;
                break;
            }
        }

        if (!inside) {
            continue;
        }

        // Add light to cluster
        light_counts
            [gl_GlobalInvocationID.z]
            [gl_GlobalInvocationID.x]
            [gl_GlobalInvocationID.y] += 1;

        clusters[gl_GlobalInvocationID.z]
                [gl_GlobalInvocationID.x]
                [gl_GlobalInvocationID.y]
                [light_idx] = i;

        light_idx += 1;
    }
}