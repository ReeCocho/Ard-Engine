use std::{
    path::{Path, PathBuf},
    process::Command,
};

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct Constants {
    pub frames_in_flight: usize,
    pub froxel_table_dims: (usize, usize, usize),
    pub max_point_lights_per_froxel: usize,
    pub max_textures_per_material: usize,
}

fn main() {
    // Load in the constants from file
    let constants = std::fs::read_to_string(Path::new("./constants.ron")).unwrap();
    let constants = ron::from_str::<Constants>(&constants).unwrap();

    // Write shader constants file
    std::fs::write(
        Path::new("./src/shader_constants.rs"),
        format!(
            "\
            /// DO NOT MODIFY: Autogenerated by `build.rs`\n\n\
            pub(crate) const FRAMES_IN_FLIGHT: usize = {};\n\
            pub(crate) const FROXEL_TABLE_DIMS: (usize, usize, usize) = ({}, {}, {});\n\
            pub(crate) const MAX_POINT_LIGHTS_PER_FROXEL: usize = {};\n\
            pub(crate) const MAX_TEXTURES_PER_MATERIAL: usize = {};\n\
            pub(crate) const NO_TEXTURE: u32 = {};\n\
            ",
            constants.frames_in_flight,
            constants.froxel_table_dims.0,
            constants.froxel_table_dims.1,
            constants.froxel_table_dims.2,
            constants.max_point_lights_per_froxel,
            constants.max_textures_per_material,
            u32::MAX,
        ),
    )
    .unwrap();

    // Shader constants
    std::fs::write(
        Path::new("./shader_includes/constants.glsl"),
        format!(
            "\
            #ifndef _CONSTANTS_GLSL\n\
            #define _CONSTANTS_GLSL\n\
            #define FROXEL_TABLE_X {}\n\
            #define FROXEL_TABLE_Y {}\n\
            #define FROXEL_TABLE_Z {}\n\
            #define MAX_POINT_LIGHTS_PER_FROXEL {}\n\
            #define MAX_TEXTURES_PER_MATERIAL {} \n\
            #define NO_TEXTURE {}\n\
            #endif\n\
            ",
            constants.froxel_table_dims.0,
            constants.froxel_table_dims.1,
            constants.froxel_table_dims.2,
            constants.max_point_lights_per_froxel,
            constants.max_textures_per_material,
            u32::MAX,
        ),
    )
    .unwrap();

    // Data structures

    // Compile shaders
    compile(
        Path::new("./src/renderer/draw_gen.comp"),
        Path::new("./src/renderer/"),
    );
    compile(
        Path::new("./src/renderer/point_light_gen.comp"),
        Path::new("./src/renderer/"),
    );
    compile(
        Path::new("./src/renderer/quad.vert"),
        Path::new("./src/renderer/"),
    );
    compile(
        Path::new("./src/renderer/zreduce.frag"),
        Path::new("./src/renderer/"),
    );
    compile(
        Path::new("./src/renderer/debug_draw.vert"),
        Path::new("./src/renderer/"),
    );
    compile(
        Path::new("./src/renderer/debug_draw.frag"),
        Path::new("./src/renderer/"),
    );
    compile(
        Path::new("./src/renderer/cluster_gen.comp"),
        Path::new("./src/renderer/"),
    );
}

fn compile(in_path: &Path, out_path: &Path) {
    // Construct the output name of the shader
    let mut out_name: PathBuf = out_path.into();
    out_name.push(in_path.file_name().unwrap());

    let mut extension: String = in_path.extension().unwrap().to_str().unwrap().into();
    extension.push_str(".spv");

    out_name.set_extension(&extension);

    // Compile the shader
    let err = format!("unable to compile {:?}", out_name);
    let stderr = Command::new("glslc")
        .arg(in_path)
        .arg("-I./shader_includes/")
        .arg("--target-env=vulkan1.2")
        .arg("-o")
        .arg(&out_name)
        .output()
        .expect(&err)
        .stderr;

    if !stderr.is_empty() {
        let err = String::from_utf8(stderr).unwrap();
        panic!("unable to compile {:?}:\n{}", in_path, err);
    }
}
